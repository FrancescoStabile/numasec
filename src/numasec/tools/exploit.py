"""
NumaSec v3 - Exploitation Tools

Simplified exploit tools: nuclei, sqlmap
~130 lines total vs 700+ in v1
"""

from __future__ import annotations

import asyncio
import json
from typing import Any

# ═══════════════════════════════════════════════════════════════════════════
# Helper: Run Command
# ═══════════════════════════════════════════════════════════════════════════


async def _run_command(cmd: list[str], timeout: int = 300) -> tuple[str, str, int]:
    """Run command with timeout. Returns (stdout, stderr, exit_code)."""
    try:
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        
        stdout, stderr = await asyncio.wait_for(
            process.communicate(),
            timeout=timeout
        )
        
        return (
            stdout.decode('utf-8', errors='ignore'),
            stderr.decode('utf-8', errors='ignore'),
            process.returncode or 0
        )
    except asyncio.TimeoutError:
        if process:
            process.kill()
            await process.wait()
        return ("", f"Command timed out after {timeout}s", 124)
    except Exception as e:
        return ("", f"Command failed: {e}", 1)


# ═══════════════════════════════════════════════════════════════════════════
# Nuclei - Vulnerability Scanner
# ═══════════════════════════════════════════════════════════════════════════


async def nuclei(
    url: str,
    severity: str = "critical,high",
    tags: str = ""
) -> str:
    """
    Run nuclei vulnerability scanner.
    
    Args:
        url: Target URL to scan
        severity: Comma-separated severities (critical,high,medium,low,info)
        tags: Comma-separated tags to filter templates
    
    Returns:
        JSON string with vulnerabilities found
    """
    cmd = [
        "nuclei",
        "-u", url,
        "-json",
        "-silent",
        "-rl", "150"  # Rate limit
    ]
    
    # Add severity filter
    if severity:
        cmd.extend(["-s", severity])
    
    # Add tags filter
    if tags:
        cmd.extend(["-tags", tags])
    
    stdout, stderr, code = await _run_command(cmd, timeout=600)
    
    if code not in [0, 1] and not stdout:  # nuclei returns 1 when findings exist
        return json.dumps({
            "error": stderr or "nuclei failed",
            "url": url
        })
    
    # Parse JSON output (one JSON per line)
    try:
        findings = []
        for line in stdout.split('\n'):
            if not line.strip():
                continue
            try:
                data = json.loads(line)
                findings.append({
                    "template": data.get("template-id", ""),
                    "name": data.get("info", {}).get("name", ""),
                    "severity": data.get("info", {}).get("severity", "info"),
                    "matched_at": data.get("matched-at", ""),
                    "type": data.get("type", ""),
                    "description": data.get("info", {}).get("description", ""),
                    "tags": data.get("info", {}).get("tags", [])
                })
            except json.JSONDecodeError:
                continue
        
        return json.dumps({
            "url": url,
            "findings": findings,
            "count": len(findings),
            "by_severity": _count_by_severity(findings)
        }, indent=2)
    
    except Exception as e:
        return json.dumps({
            "error": f"Failed to parse nuclei output: {e}",
            "url": url
        })


def _count_by_severity(findings: list[dict]) -> dict[str, int]:
    """Count findings by severity."""
    counts = {}
    for f in findings:
        sev = f.get("severity", "info")
        counts[sev] = counts.get(sev, 0) + 1
    return counts


# ═══════════════════════════════════════════════════════════════════════════
# Run Exploit — Generic exploit runner
# ═══════════════════════════════════════════════════════════════════════════


async def run_exploit(
    command: str,
    description: str = "",
    timeout: int = 120,
) -> str:
    """
    Run an exploit command. This is a dedicated tool for exploitation
    that logs clearly and allows the LLM to distinguish recon from exploit.

    Args:
        command: The exploit command to run (e.g., "python3 exploit.py TARGET")
        description: Brief description of what this exploit does
        timeout: Timeout in seconds

    Returns:
        JSON string with command output
    """
    import logging
    logger = logging.getLogger("numasec.exploit")
    logger.warning(f"EXPLOIT: {description or command}")

    # Split command for subprocess
    parts = command.split()
    if not parts:
        return json.dumps({"error": "Empty command"})

    stdout, stderr, code = await _run_command(parts, timeout=timeout)

    return json.dumps({
        "command": command,
        "description": description,
        "stdout": stdout[:5000] if stdout else "",
        "stderr": stderr[:2000] if stderr else "",
        "returncode": code,
        "success": code == 0,
    }, indent=2)


# ═══════════════════════════════════════════════════════════════════════════
# SQLMap - SQL Injection
# ═══════════════════════════════════════════════════════════════════════════


async def sqlmap(
    url: str,
    data: str = "",
    cookie: str = "",
    level: int = 1,
    risk: int = 1
) -> str:
    """
    Test for SQL injection with sqlmap.
    
    Args:
        url: Target URL with parameter (e.g., "http://site.com/page?id=1")
        data: POST data (e.g., "username=test&password=test")
        cookie: Cookie string (e.g., "PHPSESSID=abc123")
        level: Test level 1-5 (higher = more tests, slower)
        risk: Risk level 1-3 (higher = more aggressive)
    
    Returns:
        JSON string with SQL injection findings
    """
    cmd = [
        "sqlmap",
        "-u", url,
        "--batch",  # Non-interactive
        "--smart",  # Smart payload selection
        f"--level={level}",
        f"--risk={risk}",
        "--output-dir=/tmp/sqlmap",  # Prevent pollution
        "--flush-session"  # Fresh scan
    ]
    
    # Add POST data if provided
    if data:
        cmd.extend(["--data", data])
    
    # Add cookie if provided
    if cookie:
        cmd.extend(["--cookie", cookie])
    
    stdout, stderr, code = await _run_command(cmd, timeout=600)
    
    # SQLMap output is text, not JSON. Parse key info.
    try:
        # Check for injection
        vulnerable = "is vulnerable" in stdout.lower() or "injection" in stdout.lower()
        
        # Extract DBMS
        dbms = ""
        if "back-end DBMS:" in stdout:
            for line in stdout.split('\n'):
                if "back-end DBMS:" in line:
                    dbms = line.split(":")[-1].strip()
                    break
        
        # Extract parameters
        injectable_params = []
        if "Parameter:" in stdout:
            for line in stdout.split('\n'):
                if "Parameter:" in line and "is vulnerable" in stdout[stdout.index(line):]:
                    param = line.split(":")[-1].strip()
                    injectable_params.append(param)
        
        return json.dumps({
            "url": url,
            "vulnerable": vulnerable,
            "dbms": dbms,
            "injectable_parameters": injectable_params,
            "level": level,
            "risk": risk,
            "raw_output": stdout[:1000] if vulnerable else ""  # Include output if vuln found
        }, indent=2)
    
    except Exception as e:
        return json.dumps({
            "error": f"Failed to parse sqlmap output: {e}",
            "url": url
        })


# ═══════════════════════════════════════════════════════════════════════════
# Tool Schemas
# ═══════════════════════════════════════════════════════════════════════════


TOOL_SCHEMAS = {
    "nuclei": {
        "name": "nuclei",
        "description": "Fast vulnerability scanner using templates - finds common CVEs, misconfigurations, and vulnerabilities",
        "parameters": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL to scan (e.g., 'https://example.com')"
                },
                "severity": {
                    "type": "string",
                    "description": "Comma-separated severities to scan: 'critical,high,medium,low,info'",
                    "default": "critical,high"
                },
                "tags": {
                    "type": "string",
                    "description": "Comma-separated tags to filter templates (e.g., 'sqli,xss,rce')",
                    "default": ""
                }
            },
            "required": ["url"]
        }
    },
    "sqlmap": {
        "name": "sqlmap",
        "description": "Automatic SQL injection detection and exploitation - WARNING: HIGH RISK tool, can modify databases",
        "parameters": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL with parameter (e.g., 'http://site.com/page?id=1')"
                },
                "data": {
                    "type": "string",
                    "description": "POST data to test (e.g., 'username=test&password=test')",
                    "default": ""
                },
                "cookie": {
                    "type": "string",
                    "description": "Cookie string for authenticated testing (e.g., 'PHPSESSID=abc123')",
                    "default": ""
                },
                "level": {
                    "type": "integer",
                    "description": "Test level 1-5 (higher = more thorough, slower)",
                    "default": 1,
                    "minimum": 1,
                    "maximum": 5
                },
                "risk": {
                    "type": "integer",
                    "description": "Risk level 1-3 (higher = more aggressive tests)",
                    "default": 1,
                    "minimum": 1,
                    "maximum": 3
                }
            },
            "required": ["url"]
        }
    },
    "run_exploit": {
        "name": "run_exploit",
        "description": "Run an exploit command. Use this for exploitation attempts (PoC scripts, reverse shells, payload delivery). Logs as EXPLOIT for audit. Always describe what the exploit does.",
        "parameters": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The exploit command to execute (e.g., 'python3 exploit.py 10.0.0.1')"
                },
                "description": {
                    "type": "string",
                    "description": "Brief description of exploit purpose (e.g., 'CVE-2021-44228 Log4Shell RCE')",
                    "default": ""
                },
                "timeout": {
                    "type": "integer",
                    "description": "Timeout in seconds",
                    "default": 120
                }
            },
            "required": ["command"]
        }
    },
}
