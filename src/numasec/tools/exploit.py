"""
NumaSec v3 - Exploitation Tools

Simplified exploit tools: nuclei, sqlmap
~130 lines total vs 700+ in v1
"""

from __future__ import annotations

import asyncio
import json
import re
from typing import Any

# ═══════════════════════════════════════════════════════════════════════════
# Helper: Run Command
# ═══════════════════════════════════════════════════════════════════════════


async def _run_command(cmd: list[str], timeout: int = 300) -> tuple[str, str, int]:
    """Run command with timeout. Returns (stdout, stderr, exit_code)."""
    try:
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        
        stdout, stderr = await asyncio.wait_for(
            process.communicate(),
            timeout=timeout
        )
        
        return (
            stdout.decode('utf-8', errors='ignore'),
            stderr.decode('utf-8', errors='ignore'),
            process.returncode or 0
        )
    except asyncio.TimeoutError:
        if process:
            process.kill()
            await process.wait()
        return ("", f"Command timed out after {timeout}s", 124)
    except Exception as e:
        return ("", f"Command failed: {e}", 1)


# ═══════════════════════════════════════════════════════════════════════════
# Nuclei - Vulnerability Scanner
# ═══════════════════════════════════════════════════════════════════════════


async def nuclei(
    url: str,
    severity: str = "critical,high",
    tags: str = ""
) -> str:
    """
    Run nuclei vulnerability scanner.
    
    Args:
        url: Target URL to scan
        severity: Comma-separated severities (critical,high,medium,low,info)
        tags: Comma-separated tags to filter templates
    
    Returns:
        JSON string with vulnerabilities found
    """
    cmd = [
        "nuclei",
        "-u", url,
        "-json",
        "-silent",
        "-rl", "150"  # Rate limit
    ]
    
    # Add severity filter
    if severity:
        cmd.extend(["-s", severity])
    
    # Add tags filter
    if tags:
        cmd.extend(["-tags", tags])
    
    stdout, stderr, code = await _run_command(cmd, timeout=600)
    
    if code not in [0, 1] and not stdout:  # nuclei returns 1 when findings exist
        return json.dumps({
            "error": stderr or "nuclei failed",
            "url": url
        })
    
    # Parse JSON output (one JSON per line)
    try:
        findings = []
        for line in stdout.split('\n'):
            if not line.strip():
                continue
            try:
                data = json.loads(line)
                findings.append({
                    "template": data.get("template-id", ""),
                    "name": data.get("info", {}).get("name", ""),
                    "severity": data.get("info", {}).get("severity", "info"),
                    "matched_at": data.get("matched-at", ""),
                    "type": data.get("type", ""),
                    "description": data.get("info", {}).get("description", ""),
                    "tags": data.get("info", {}).get("tags", [])
                })
            except json.JSONDecodeError:
                continue
        
        return json.dumps({
            "url": url,
            "findings": findings,
            "count": len(findings),
            "by_severity": _count_by_severity(findings)
        }, indent=2)
    
    except Exception as e:
        return json.dumps({
            "error": f"Failed to parse nuclei output: {e}",
            "url": url
        })


def _count_by_severity(findings: list[dict]) -> dict[str, int]:
    """Count findings by severity."""
    counts = {}
    for f in findings:
        sev = f.get("severity", "info")
        counts[sev] = counts.get(sev, 0) + 1
    return counts


# ═══════════════════════════════════════════════════════════════════════════
# Run Exploit — Generic exploit runner
# ═══════════════════════════════════════════════════════════════════════════



# ═══════════════════════════════════════════════════════════════════════════
# Security: Command Allowlist for run_exploit
# ═══════════════════════════════════════════════════════════════════════════

# Only these binaries are allowed as the first argument to run_exploit.
# This prevents arbitrary command execution (e.g. rm -rf /, curl exfil, etc.)
EXPLOIT_ALLOWLIST: set[str] = {
    # Python/scripting (for PoC scripts)
    "python3", "python", "python3.11", "python3.12", "python3.13",
    # Security tools
    "nuclei", "sqlmap", "nmap", "nikto", "gobuster", "feroxbuster",
    "ffuf", "wfuzz", "hydra", "medusa", "john", "hashcat",
    "msfconsole", "msfvenom", "searchsploit",
    # Network utilities
    "curl", "wget", "nc", "ncat", "netcat", "socat",
    "openssl", "ssh", "scp",
    # Enumeration
    "enum4linux", "smbclient", "rpcclient", "ldapsearch",
    "dig", "host", "whois", "dnsrecon",
    # Web
    "whatweb", "wpscan", "joomscan", "droopescan",
    # Misc exploit tools
    "responder", "impacket-smbserver", "impacket-psexec",
    "impacket-wmiexec", "impacket-secretsdump",
    "chisel", "ligolo-ng",
}

# Shell metacharacters that indicate command chaining/injection
_SHELL_METACHAR_PATTERN = re.compile(r"[;&|`$(){}]|>>|<<")


def _validate_exploit_command(command: str, scope_targets: list[str] | None = None) -> str | None:
    """
    Validate an exploit command against the allowlist.
    Returns an error message if blocked, None if OK.
    """
    import shlex as _shlex

    try:
        parts = _shlex.split(command.strip())
    except ValueError:
        parts = command.strip().split()

    if not parts:
        return "Empty command"

    binary = parts[0].split("/")[-1]  # Handle /usr/bin/python3 → python3

    if binary not in EXPLOIT_ALLOWLIST:
        return (
            f"BLOCKED: '{binary}' is not in the exploit allowlist. "
            f"Allowed binaries: {', '.join(sorted(EXPLOIT_ALLOWLIST)[:15])}... "
            f"Use 'python3 exploit.py' for custom scripts."
        )

    # Block shell metacharacters (prevent chaining: cmd1 && cmd2, cmd1 | cmd2)
    if _SHELL_METACHAR_PATTERN.search(command):
        return (
            f"BLOCKED: Shell metacharacters detected in command. "
            f"Run one command at a time, no pipes or chaining."
        )

    # Scope check for curl/wget — prevent data exfiltration
    if binary in ("curl", "wget") and scope_targets:
        urls_in_cmd = re.findall(r'https?://[^\s"\']+', command)
        from urllib.parse import urlparse
        for url in urls_in_cmd:
            url_host = urlparse(url).hostname or ""
            in_scope = False
            for allowed in scope_targets:
                scope_host = urlparse(
                    allowed if "://" in allowed else f"http://{allowed}"
                ).hostname or ""
                if url_host == scope_host or url_host.endswith("." + scope_host):
                    in_scope = True
                    break
            if not in_scope:
                return (
                    f"BLOCKED: {binary} targets out-of-scope URL: {url}. "
                    f"Allowed scope: {scope_targets}"
                )

    return None


async def run_exploit(
    command: str,
    description: str = "",
    timeout: int = 120,
    scope_targets: list[str] | None = None,
) -> str:
    """
    Run an exploit command. This is a dedicated tool for exploitation
    that logs clearly and allows the LLM to distinguish recon from exploit.

    Security: Commands are validated against an allowlist of known security
    tools. Shell metacharacters (pipes, chaining) are blocked.

    Args:
        command: The exploit command to run (e.g., "python3 exploit.py TARGET")
        description: Brief description of what this exploit does
        timeout: Timeout in seconds

    Returns:
        JSON string with command output
    """
    import logging
    logger = logging.getLogger("numasec.exploit")

    # Security: validate against allowlist + scope
    block_reason = _validate_exploit_command(command, scope_targets=scope_targets)
    if block_reason:
        logger.warning(f"EXPLOIT BLOCKED: {command} — {block_reason}")
        return json.dumps({"error": block_reason, "command": command})

    logger.warning(f"EXPLOIT: {description or command}")

    # Split command safely for subprocess
    import shlex as _shlex
    try:
        parts = _shlex.split(command)
    except ValueError:
        parts = command.split()
    if not parts:
        return json.dumps({"error": "Empty command"})

    stdout, stderr, code = await _run_command(parts, timeout=timeout)

    return json.dumps({
        "command": command,
        "description": description,
        "stdout": stdout[:5000] if stdout else "",
        "stderr": stderr[:2000] if stderr else "",
        "returncode": code,
        "success": code == 0,
    }, indent=2)


# ═══════════════════════════════════════════════════════════════════════════
# SQLMap - SQL Injection
# ═══════════════════════════════════════════════════════════════════════════


async def sqlmap(
    url: str,
    data: str = "",
    cookie: str = "",
    level: int = 1,
    risk: int = 1
) -> str:
    """
    Test for SQL injection with sqlmap.
    
    Args:
        url: Target URL with parameter (e.g., "http://site.com/page?id=1")
        data: POST data (e.g., "username=test&password=test")
        cookie: Cookie string (e.g., "PHPSESSID=abc123")
        level: Test level 1-5 (higher = more tests, slower)
        risk: Risk level 1-3 (higher = more aggressive)
    
    Returns:
        JSON string with SQL injection findings
    """
    cmd = [
        "sqlmap",
        "-u", url,
        "--batch",  # Non-interactive
        "--smart",  # Smart payload selection
        f"--level={level}",
        f"--risk={risk}",
        "--output-dir=/tmp/sqlmap",  # Prevent pollution
        "--flush-session"  # Fresh scan
    ]
    
    # Add POST data if provided
    if data:
        cmd.extend(["--data", data])
    
    # Add cookie if provided
    if cookie:
        cmd.extend(["--cookie", cookie])
    
    stdout, stderr, code = await _run_command(cmd, timeout=600)
    
    # SQLMap output is text, not JSON. Parse key info.
    try:
        # Check for injection
        vulnerable = "is vulnerable" in stdout.lower() or "injection" in stdout.lower()
        
        # Extract DBMS
        dbms = ""
        if "back-end DBMS:" in stdout:
            for line in stdout.split('\n'):
                if "back-end DBMS:" in line:
                    dbms = line.split(":")[-1].strip()
                    break
        
        # Extract parameters
        injectable_params = []
        if "Parameter:" in stdout:
            for line in stdout.split('\n'):
                if "Parameter:" in line and "is vulnerable" in stdout[stdout.index(line):]:
                    param = line.split(":")[-1].strip()
                    injectable_params.append(param)
        
        return json.dumps({
            "url": url,
            "vulnerable": vulnerable,
            "dbms": dbms,
            "injectable_parameters": injectable_params,
            "level": level,
            "risk": risk,
            "raw_output": stdout[:1000] if vulnerable else ""  # Include output if vuln found
        }, indent=2)
    
    except Exception as e:
        return json.dumps({
            "error": f"Failed to parse sqlmap output: {e}",
            "url": url
        })


# ═══════════════════════════════════════════════════════════════════════════
# Tool Schemas
# ═══════════════════════════════════════════════════════════════════════════


TOOL_SCHEMAS = {
    "nuclei": {
        "name": "nuclei",
        "description": (
            "Fast vulnerability scanner using 8000+ community templates — detects known CVEs, "
            "misconfigurations, exposed panels, default credentials, and common vulnerabilities "
            "across web applications, APIs, and network services. "
            "**When to use**: After initial recon (httpx + nmap) to check for known vulnerabilities "
            "matching the detected technology stack. Run with severity='critical,high' first for quick "
            "wins, then 'medium,low' for comprehensive coverage. Use tags to focus on specific vuln "
            "types (e.g., tags='sqli,xss,rce' for web apps, tags='cve' for known CVEs). "
            "**When NOT to use**: For custom/business-logic vulnerabilities (use http tool with manual "
            "payloads). For SQL injection testing specifically (use sqlmap — it's more thorough). "
            "For authenticated testing (nuclei doesn't handle login sessions). "
            "**Output**: JSON with findings array, each containing template name, severity, matched URL, "
            "and extracted data. Empty findings = no known vulnerabilities detected. "
            "**Performance**: ~15-30s for critical+high on a single URL. Full severity scan takes ~2min. "
            "**Workflow**: httpx (tech detection) → nuclei (known CVEs for that tech) → manual testing."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL to scan (e.g., 'http://localhost:3000', 'https://app.example.com')"
                },
                "severity": {
                    "type": "string",
                    "description": "Comma-separated severities: 'critical,high' (recommended first pass), 'medium,low,info' (comprehensive). Default: critical,high.",
                    "default": "critical,high"
                },
                "tags": {
                    "type": "string",
                    "description": "Filter templates by tags (e.g., 'sqli,xss,rce,lfi', 'cve', 'misconfig', 'exposure'). Empty = all templates.",
                    "default": ""
                }
            },
            "required": ["url"]
        }
    },
    "sqlmap": {
        "name": "sqlmap",
        "description": (
            "Automatic SQL injection detection and exploitation. The gold standard for SQLi testing — "
            "detects error-based, blind (boolean/time), UNION, and stacked queries injection across "
            "MySQL, PostgreSQL, SQLite, MSSQL, Oracle, and more. "
            "**WARNING**: HIGH RISK tool — can modify databases at higher risk levels. Always start with "
            "level=1, risk=1 (safe detection only). Escalate to level=3+ only if initial detection fails "
            "and you strongly suspect SQLi. "
            "**When to use**: After finding a potentially injectable parameter via manual probing "
            "(e.g., http tool returned errors with ' in parameter). Provide the exact URL with the "
            "vulnerable parameter. For POST endpoints, include the data parameter. "
            "**When NOT to use**: As a first-pass scanner (use nuclei first — it's faster). When "
            "you don't have a specific parameter to test. Against production databases without "
            "explicit authorization. "
            "**Output**: JSON with injection type, DBMS detected, injectable parameters, and sample data. "
            "**Workflow**: http (manual probe for errors) → sqlmap (confirm and classify injection) → "
            "create_finding (document the vulnerability). "
            "**Common mistake**: Testing the root URL without parameters. SQLmap needs a specific "
            "parameter to test (e.g., ?id=1, POST data with username=test)."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "description": "Target URL WITH the injectable parameter (e.g., 'http://site.com/users?id=1', 'http://site.com/login')"
                },
                "data": {
                    "type": "string",
                    "description": "POST body to test (e.g., 'username=test&password=test'). Required for POST injection points.",
                    "default": ""
                },
                "cookie": {
                    "type": "string",
                    "description": "Cookie string for authenticated testing (e.g., 'PHPSESSID=abc123; token=xyz')",
                    "default": ""
                },
                "level": {
                    "type": "integer",
                    "description": "Test thoroughness 1-5: 1=basic (fast, safe), 2=more payloads, 3=user-agent/referer, 4-5=aggressive (slow). Start at 1.",
                    "default": 1,
                    "minimum": 1,
                    "maximum": 5
                },
                "risk": {
                    "type": "integer",
                    "description": "Risk level 1-3: 1=safe (read-only), 2=time-based tests, 3=OR-based (may modify data). Start at 1.",
                    "default": 1,
                    "minimum": 1,
                    "maximum": 3
                }
            },
            "required": ["url"]
        }
    },
    "run_exploit": {
        "name": "run_exploit",
        "description": (
            "Execute an exploit command for proof-of-concept testing. Use this for running PoC scripts, "
            "custom exploitation tools, and security utilities that don't have a dedicated tool. "
            "Logs all commands as EXPLOIT for audit trail. "
            "**Security**: Commands are validated against an allowlist of known security tools "
            "(python3, curl, nmap, nuclei, sqlmap, etc.). Shell metacharacters (pipes, chaining) "
            "are blocked to prevent command injection. "
            "**When to use**: Running downloaded PoC scripts (e.g., 'python3 cve-2021-44228.py target'), "
            "using tools not in the standard toolkit, executing custom payloads. Always provide a "
            "description of what the exploit does. "
            "**When NOT to use**: For nmap/nuclei/sqlmap/ffuf (use their dedicated tools — they have "
            "better output parsing and error handling). For simple HTTP requests (use http tool). "
            "**Output**: JSON with stdout, stderr, exit_code, and the command that was run. "
            "**Common mistake**: Using shell pipes (|) or command chaining (&&) — these are blocked. "
            "Run one command at a time."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The exploit command to execute (e.g., 'python3 exploit.py http://target', 'curl -X POST http://target/rce')"
                },
                "description": {
                    "type": "string",
                    "description": "REQUIRED: Brief description of what this exploit does (e.g., 'CVE-2021-44228 Log4Shell RCE', 'Testing SSTI via Jinja2 payload')",
                    "default": ""
                },
                "timeout": {
                    "type": "integer",
                    "description": "Timeout in seconds — increase for slow exploits, decrease for quick checks",
                    "default": 120
                }
            },
            "required": ["command"]
        }
    },
}
