# Heap Exploitation Techniques

## Heap Basics (glibc)

```
Chunk structure (in-use):
┌──────────────────┐
│ prev_size (8B)   │ ← only if previous chunk is free
│ size + flags (8B)│ ← size | PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA
│ user data...     │
└──────────────────┘

Chunk structure (free):
┌──────────────────┐
│ prev_size (8B)   │
│ size + flags (8B)│
│ fd (8B)          │ ← pointer to next free chunk
│ bk (8B)          │ ← pointer to previous free chunk
│ ...              │
└──────────────────┘

Minimum chunk size: 0x20 (32 bytes) on 64-bit
```

## Bin Types

```
Tcache bins (glibc 2.26+):
- Per-thread cache, LIFO (singly-linked)
- 64 bins for sizes 0x20-0x410 (64-bit)
- Max 7 entries per bin (default)
- First checked on malloc, first filled on free
- Fastest allocation/deallocation path

Fast bins:
- LIFO (singly-linked), no coalescing
- Sizes: 0x20-0x80 (64-bit, 10 bins)
- Checked after tcache on malloc

Unsorted bin:
- Doubly-linked, single bin
- Chunks go here after tcache/fastbin are full
- Malloc searches here first for exact/close fit
- Contains libc pointers (useful for leaks!)

Small bins (< 0x400):
- Doubly-linked, FIFO, 62 bins
- Exact size match

Large bins (≥ 0x400):
- Doubly-linked, sorted by size
- Range-based matching
```

## Tcache Poisoning (glibc 2.26-2.33)

```python
# Overwrite tcache entry's fd pointer → arbitrary allocation
# 1. Free chunk A → tcache[size]: A → NULL
# 2. Overwrite A's fd to target address
# 3. malloc(size) → returns A
# 4. malloc(size) → returns target address!

from pwn import *

# After UAF or overflow:
# Write target address into freed chunk's fd field
edit(chunk_a_idx, p64(target_addr))  # overwrite fd
alloc(size)  # consumes A
alloc(size)  # returns target_addr → write arbitrary data
```

## Safe-Linking Bypass (glibc 2.34+)

```python
# fd is now mangled: stored_fd = (real_fd >> 12) ^ ptr_to_chunk
# Need heap leak to compute correct mangled pointer

# To set fd to TARGET:
# stored_fd = (TARGET) ^ (heap_addr >> 12)
# where heap_addr is the address of the chunk being poisoned

def mangle(heap_addr, target):
    return (heap_addr >> 12) ^ target

def demangle(heap_addr, stored_fd):
    return (heap_addr >> 12) ^ stored_fd

# Leak: if you can read a freed tcache chunk's fd:
# stored_fd = real_fd ^ (chunk_addr >> 12)
# For first free: real_fd = 0, so stored_fd = chunk_addr >> 12
# → Partial heap leak from first tcache free
```

## Fastbin Dup (glibc < 2.26, or after tcache filled)

```python
# Double free with different chunk in between
# free(A), free(B), free(A) → fastbin: A → B → A → B → ...
# alloc → A (write target as fd)
# alloc → B
# alloc → A (now points to target)
# alloc → target

# Size check bypass: target must have valid size field
# Common targets: __malloc_hook, __free_hook (before glibc 2.34)
```

## Use-After-Free (UAF)

```python
# 1. Allocate chunk with function pointer or vtable
# 2. Free it (goes to tcache/fastbin)
# 3. Allocate same-size chunk → gets same memory
# 4. Write controlled data → overwrite function pointer
# 5. Trigger call through original reference → code execution

# Key: same-size allocation reuses the freed chunk
# Heap spray: allocate many same-size chunks to increase reliability
```

## Unsorted Bin Attack

```python
# Free a chunk larger than tcache/fastbin range
# → Goes to unsorted bin
# → fd and bk point to &main_arena.top → libc address!

# Leak: read freed unsorted bin chunk → get libc pointer
# UAF read on freed chunk → libc leak

# Unsorted bin overwrite (glibc < 2.29):
# Overwrite bk of unsorted bin chunk
# → Next malloc writes &unsorted_bin to bk->fd
# → Write a libc address to arbitrary location
```

## House of Force (glibc < 2.29)

```python
# Overwrite wilderness (top chunk) size to 0xffffffffffffffff
# Request: target_addr - top_addr - 2*sizeof(size_t)
# Next malloc returns target address

# Requires:
# 1. Heap overflow into top chunk size
# 2. Know heap address (for size calculation)
# 3. Know target address
```

## House of Spirit

```python
# Forge a fake chunk in controlled memory (stack, BSS, etc.)
# Free the fake chunk → goes to tcache/fastbin
# Malloc same size → returns the fake chunk address
# → Arbitrary write on stack/BSS

# Requirements:
# Fake chunk needs valid size (and next chunk's size for validation)
```

## Tcache Stashing Unlink (glibc 2.29+)

```python
# When smallbin has entries and tcache is not full:
# Malloc from smallbin → remaining entries "stashed" to tcache
# During stashing: chunk->bk->fd = &tcache_bin (write!)
# → Overwrite chunk's bk to get arbitrary write during stashing

# Useful because it bypasses safe-linking (operates on smallbin, not tcache fd)
```

## FSOP (File Stream Oriented Programming)

```python
# Overwrite _IO_FILE structures (stdout, stderr, etc.)
# _IO_FILE has vtable pointer → redirect to controlled functions

# glibc 2.24+: vtable must be in __libc_IO_vtables section
# Bypass: use _IO_str_overflow or _IO_wstr_overflow

# House of Apple (glibc 2.34+):
# Combine with FSOP + _IO_wfile_overflow for RCE
# Target: _wide_data pointer in _IO_FILE
```

## Libc Leak Strategies

```
1. Unsorted bin: free large chunk → read fd/bk → libc addr
2. stdout leak: overwrite _IO_write_base of stdout → leak on next print
3. Format string: %p to leak stack → find libc return address
4. GOT leak: read GOT entries → resolved libc addresses
5. Partial overwrite: overwrite lower bytes of libc pointer → redirect
```

## Common Targets for Write

```
Pre-glibc 2.34:
- __malloc_hook → called on every malloc
- __free_hook → called on every free
- __realloc_hook → called on realloc

glibc 2.34+ (hooks removed):
- GOT entries → redirect library calls
- _IO_FILE vtables → FSOP
- Return addresses on stack
- atexit handlers
- TLS (thread-local storage) destructor
```
